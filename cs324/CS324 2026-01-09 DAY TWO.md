2026 01 09  
CS 324  
Dougal  
DAY TWO

---

I'm sitting in on Dougal's section today, instead of Deccio's. Hopefully that won't screw me over. idk.

---

# Command-Line Arguments (finishing up last time)

- The first arg is always the name of the executable.

# Reading from stdin

## `fgets()`

```c
#include <stdio.h>

#define BUFSIZE 64

int main(int argc, char *argv[]) {
    char buf[BUFSIZE];
    fgets(buf, BUFSIZE, stdin);
    printf("You entered via stdin: %s\n", buf);
}
```

`fgets(pointer, buffer_size, stream)` reads from stdin:


- Reads from 
- reads at most `buffer_size - 1` (bc the last byte is reserved for the null character).

# Environment variables

## Getting environment variables

### `getenv()`

`getenv("name")`

gets environment variable called `"name"`.

### Setting environmennt variables

```bash
MYVAR=slimy ./main
```

^ sets for just that execution.

```bash
export MYVAR=slimy
./main
```

^ sets for that execution and all future ones.

---

Now for today's content.

# System

- Environment
- Command-line args
- Standard input (`stdin` in C)

# Exit Codes

An "exit code" or "exit status" is a numeric value returned by a process or command upon its termination.

The exit status yielded by a program indicates whether the process completed successfully or if it encountered an error.



## Common Exit codes

- 0 indicates successful execution w/ no errors.
- 1 represents a generic error.
- 2 denotes incorrect usage, e.g. invalid options or missing args.
- 126: command found but not executable (e.g., insufficient permissions)
- 127: command not found, often due to a missing executable in the `$PATH` (whatever ts is)
- 128+$N$: Indicates termination by a signal. $N$ is the signal.

## Retrieving exit codes

The exit code of the last executed command can be retrieved using the special variable `$?`.

e.g.

```bash
$ ls
$ echo $?
0  
```

# File Descriptors

- Linux treats *everything* as a file.
    - Regular files, directories, and even devices are "files".
- A file is a byte array. 

Every file has a number called the *file descriptor* (FD).

- non-negative integer
    - ranges from `0` to `OPEN_MAX`
- When we open an existing file or create a new one, it is assigned an FD. (I think.)
- The kernal maintains a table of all open FDs that are in use (the FD table).
    - ***Each process* has its own FD table.**
- The allotment of FDs is generally sequential.
- When we close a file, its FD gets freed and is availble for re-use.
- Every program gets three FDs: $0$, $1$, and $2$, corresponding respectively to `stdin`, `stdout`, and `stderr`.
    - So the first file you open/create will have an FD of $3$.

## e.g. code

```c
#include <stdio.h>

int main() {
    fprintf(stdout, "Hello from STDOUT\n");
    fprintf(stderr, "Hello from STDERR\n");
} 
```

### Note on printing to stdout vs. stderr

`stdout` is buffered. `stderr` is NOT. So the order of print statements may come out wonky. 

# I/O Redirection

```txt
PROCESS-specific            SYSTEM-wide             Device (PTY)
----------------            -----------             ------------
0 (stdin)           -->                     -->
1 (stdout)          -->                     -->
2 (stderr)          -->                     -->
```

The process-specific FD table is for just that process. But it maps to the system-wide FD table&mdash;which there is only one of on your system.

By default, stdin points to your keyboard, and stdout and stderr both map to your terminal.

## (Terminology: PTY)

PTY means "pseudo-TTY":

- In Linux, TTY refers to terminal devices that lalow users to interact w/ the system by sending inputs and receiving outputs.
- A "pseudo-device" is a device that has the functions of a physical terminal w/o actually being one. (Although it could be. ...?)
- Pseudo-TTY (PTY) is a pair of pseudo-device endpoints that establish an asynchronous, bidirection comm channel btwn two or more processes. (or smth like that idrk he's moving rly fast through ts slides.)

## Redirecting

```c
#include <stdio.h>

int main() {
    fprintf(stdout, "Hello from STDOUT\n");
    fprintf(stderr, "Hello from STDERR\n");
} 
```

Here's what happens when you run this normally:

```bash
$ ./prog
Hello from STDOUT
Hello from STDERR
```

Now check this out:

```bash
$ ./prog 1> bar.txt
Hello from STDERR
$ cat bar.txt
Hello from STDOUT
```

For `./prog 1> bar.txt`, the output of stdout was rerouted to `bar.txt`. Stdout is FD1; then, when the program opens `bar.txt`, it assigns that to FD3; so the process reroutes output from FD1 (stdout) to FD3 (bar.txt).

```txt
PROCESS-specific            SYSTEM-wide             Device (PTY)
----------------            -----------             ------------
0 (stdin)           -->                     -->
1 (stdout)     --                           -->
2 (stderr)       \  -->                     -->
3 (file)          \===>                     -->         files
```

The specific steps for that are thus:

1. Open file `bar.txt` for writing.
2. Close current `stdout` descriptor.
3. Duplicate file descriptor (copy from FD3) to FD1.
4. Run program.


# There are only two operating systems

There are only two (major) operating systems: Linux (and other UNIX derivatives) and Windows.

(There's a bunch of other smaller ones out there, too, but they don't matter as much.)

Linux uses file descriptors. Windows has "handles". They serve the same purpose, but function very dfiferently.

In Linux, everything is a file. In Windows, everything is an object.

# Technology Disconnect Challenge for Extra Credit

For this class, you can accept a "disconnect" challenge where you will disconnect from all electronic devices during the following times:

1. During CS 324 class. (Dougale's fine w/ laptops for notes tho.)
2. During a weekly time of your choosing (e.g., church or another meeting).
3. During a daily time of your choosing (e.g., walking to/from school, btwn classes, during scipture study, before bed, etc.)

This challenge is not required&mdash;but you will get EC for trying it and turning in a report of your experience at the end of your semester. (Your response in this report/reflection will not influence whether or not you get the EC.)




# REVIEW QUESTIONS

- *What are the three default, system-provided ways a program receives input dynamically at runtime?*
    - stdin, stdout, stderr.
- *What is an environment variable?*
    - Format: Key-value pair.
    - Can be accessed anywhere in the environment.
    - In memory, env vars reside "above" the stack. 
- *How is an env var set from the shell?*
    - `VAR=value ./main`: sets `VAR` to `value` to that execution of `./main` only.
    - `export VAR=value`: sets `VAR` to `value` for that execution and all future executions.
- *How to get env vars in C?*
    - `getenv()`. Takes a string and returns the value of the env var w/ that name. 

## What does "environment" mean in the context of environment variables?

- The kernel is the master of your Linux system.
- The kernal is a shell. (We'll talk more ab this later.)
    - A "shell" is a "process". 